// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.22 <0.9.0;

import { PRBTest } from "@prb/test/PRBTest.sol";
import { console2 } from "forge-std/console2.sol";
import { StdCheats } from "forge-std/StdCheats.sol";
import { ERC20, IERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import { ETHStakingIndex } from "../src/ETHStakingIndex.sol";

/// @notice Because stETH reads balanceOf() dynamically based off ETH being deposited into
/// the stETH contract, it often returns 1 wei off. We deal with this using assertAlmostEq()
// See https://etherscan.deth.net/token/0xae7ab96520de3a18e5e111b5eaab095312d7fe84 , StETH.sol, line 166
contract ETHStakingIndexTest is PRBTest, StdCheats {
    ETHStakingIndex internal est;

    // Underlying LSD tokens
    IERC20 private immutable stETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);
    IERC20 private immutable rETH = IERC20(0xae78736Cd615f374D3085123A210448E74Fc6393);
    IERC20 private immutable cbETH = IERC20(0xBe9895146f7AF43049ca1c1AE358B0541Ea49704);

    // Whale addresses cherry-picked from etherscan
    address private stETHWhale = 0xd8d041705735cd770408AD31F883448851F2C39d;
    address private rETHWhale = 0x714301eB35fE043FAa547976ce15BcE57BD53144;
    address private cbETHWhale = 0xD55C16D4222f46148B533166032B242109b92c22;

    address private user1 = address(1);
    address private owner = address(99);

    uint256 private constant ONE_THOUSAND = 1000 * 10 ** 18;
    uint256 private constant ONE_HUNDRED = 100 * 10 ** 18;

    /// @dev A function invoked before each test case is run.
    function setUp() public virtual {
        string memory API_KEY_ALCHEMY = vm.envString("API_KEY_ALCHEMY");
        if (bytes(API_KEY_ALCHEMY).length == 0) {
            revert("Provide API_KEY_ALCHEMY in .env file");
        }
        vm.createSelectFork({ urlOrAlias: "mainnet", blockNumber: 18_823_000 });
        // string memory alchemyApiKey = vm.envOr("API_KEY_ALCHEMY", string("")); // TODO - remove

        vm.prank(owner);
        est = new ETHStakingIndex();

        // Fund user1
        vm.prank(stETHWhale);
        stETH.transfer(user1, ONE_THOUSAND);
        vm.prank(rETHWhale);
        rETH.transfer(user1, ONE_THOUSAND);
        vm.prank(cbETHWhale);
        cbETH.transfer(user1, ONE_THOUSAND);

        // Approve est to spend user1's tokens
        vm.startPrank(user1);
        stETH.approve(address(est), ONE_THOUSAND);
        rETH.approve(address(est), ONE_THOUSAND);
        cbETH.approve(address(est), ONE_THOUSAND);
        est.approve(address(est), ONE_THOUSAND);
        vm.stopPrank();
    }

    /// @dev Make sure stETH, rETH, and cbETH addresses are setup correctly
    function test_indexTokens() external {
        address[] memory tokens = est.indexTokens();
        vm.createSelectFork({ urlOrAlias: "mainnet", blockNumber: 18_823_000 });
        assertEq(ERC20(tokens[0]).symbol(), "stETH", "stETH address mismatch");
        assertEq(ERC20(tokens[1]).symbol(), "rETH", "rETH address mismatch");
        assertEq(ERC20(tokens[2]).symbol(), "cbETH", "cbETH address mismatch");
    }

    function test_mint() external {
        uint256 stBefore = stETH.balanceOf(address(user1));
        uint256 rBefore = rETH.balanceOf(address(user1));
        uint256 cbBefore = cbETH.balanceOf(address(user1));

        // Mint 100 tokens
        vm.prank(user1);
        est.mint(ONE_HUNDRED);

        uint256 stAfter = stETH.balanceOf(address(user1));
        uint256 rAfter = rETH.balanceOf(address(user1));
        uint256 cbAfter = cbETH.balanceOf(address(user1));

        // Check balances
        assertAlmostEq(stAfter, stBefore - ONE_HUNDRED, 1 wei, "stETH balance mismatch");
        assertEq(rAfter, rBefore - ONE_HUNDRED, "rETH balance mismatch");
        assertEq(cbAfter, cbBefore - ONE_HUNDRED, "cbETH balance mismatch");
        assertEq(est.balanceOf(user1), ONE_HUNDRED, "Index token balance mismatch");
    }

    function test_burn() external {
        uint256 stBefore = stETH.balanceOf(address(user1));
        uint256 rBefore = rETH.balanceOf(address(user1));
        uint256 cbBefore = cbETH.balanceOf(address(user1));
        uint256 indexTokenBefore = est.balanceOf(user1);

        // Mint 100 tokens
        vm.prank(user1);
        est.mint(ONE_HUNDRED);

        // Burn 100 tokens
        vm.prank(user1);
        est.burn(ONE_HUNDRED);

        uint256 stAfter = stETH.balanceOf(address(user1));
        uint256 rAfter = rETH.balanceOf(address(user1));
        uint256 cbAfter = cbETH.balanceOf(address(user1));
        uint256 indexTokenAfter = est.balanceOf(user1);

        // Check balances
        uint256 fee = est.calcFee(ONE_HUNDRED);
        assertAlmostEq(stAfter, stBefore - fee, 1 wei, "stETH balance mismatch");
        assertEq(rAfter, rBefore - fee, "rETH balance mismatch");
        assertEq(cbAfter, cbBefore - fee, "cbETH balance mismatch");
        assertEq(indexTokenAfter, indexTokenBefore, "Index token balance mismatch");
    }

    function test_withdrawFees() external {
        uint256 stBefore = stETH.balanceOf(address(user1));
        uint256 rBefore = rETH.balanceOf(address(user1));
        uint256 cbBefore = cbETH.balanceOf(address(user1));

        // Mint 100 tokens
        vm.prank(user1);
        est.mint(ONE_HUNDRED);

        // Burn 500 tokens
        vm.prank(user1);
        est.burn(ONE_HUNDRED / 2);

        vm.prank(owner);
        est.withdrawFees();

        uint256 stAfterEST = stETH.balanceOf(address(est));
        uint256 stAfterUser = stETH.balanceOf(address(user1));
        uint256 stAfterOwner = stETH.balanceOf(address(owner));
        uint256 rAfterEST = rETH.balanceOf(address(est));
        uint256 rAfterUser = rETH.balanceOf(address(user1));
        uint256 rAfterOwner = rETH.balanceOf(address(owner));
        uint256 cbAfterEST = cbETH.balanceOf(address(est));
        uint256 cbAfterUser = cbETH.balanceOf(address(user1));
        uint256 cbAfterOwner = cbETH.balanceOf(address(owner));

        // Confirm fee, est bal, and user bal all add up to original user balance
        assertAlmostEq(stAfterEST + stAfterOwner + stAfterUser, stBefore, 1 wei, "stETH doesn't add up");
        assertEq(rAfterEST + rAfterOwner + rAfterUser, rBefore, "rETH doesn't add up");
        assertEq(cbAfterEST + cbAfterOwner + cbAfterUser, cbBefore, "cbETH doesn't add up");

        // Confirm withdraw fees is individually correct
        uint256 expectedFee = est.calcFee(ONE_HUNDRED / 2);
        assertAlmostEq(expectedFee, stAfterOwner, 1 wei, "stETH withdrawn fees mismatch");
        assertEq(expectedFee, rAfterOwner, "rETH withdrawn fees mismatch");
        assertEq(expectedFee, cbAfterOwner, "cbETH withdrawn fees mismatch");
    }

    // TODO test the failure mode happens
    // TODO test_mint_fail with vm.expectRevert
    // TODO test onlyOwner
    // TODO test multiple users
}
