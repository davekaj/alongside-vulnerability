// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.22 <0.9.0;

import { PRBTest } from "@prb/test/PRBTest.sol";
import { console2 } from "forge-std/console2.sol";
import { StdCheats } from "forge-std/StdCheats.sol";
import { ERC20, IERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import { ETHStakingIndex } from "../src/ETHStakingIndex.sol";

/// @dev If this is your first time with Forge, read this tutorial in the Foundry Book:
/// https://book.getfoundry.sh/forge/writing-tests
contract ETHStakingIndexTest is PRBTest, StdCheats {
    ETHStakingIndex internal est;

    // Underlying LSD tokens
    IERC20 immutable stETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);
    IERC20 immutable rETH = IERC20(0xae78736Cd615f374D3085123A210448E74Fc6393);
    IERC20 immutable cbETH = IERC20(0xBe9895146f7AF43049ca1c1AE358B0541Ea49704);

    address public stETHWhale = 0xd8d041705735cd770408AD31F883448851F2C39d;
    address public rETHWhale = 0x714301eB35fE043FAa547976ce15BcE57BD53144;
    address public cbETHWhale = 0xD55C16D4222f46148B533166032B242109b92c22;

    address public user1 = address(1);
    address public owner = address(99); //0xed320Bf569E5F3c4e9313391708ddBFc58e296bb;

    uint256 public constant ONE_THOUSAND = 1000 * 10 ** 18;
    uint256 public constant ONE_HUNDRED = 1000 * 10 ** 18;

    /// @dev A function invoked before each test case is run.
    function setUp() public virtual {
        string memory API_KEY_ALCHEMY = vm.envString("API_KEY_ALCHEMY");
        if (bytes(API_KEY_ALCHEMY).length == 0) {
            revert("Please provide API_KEY_ALCHEMY in your .env file");
        }
        vm.createSelectFork({ urlOrAlias: "mainnet", blockNumber: 18_823_000 });
        // string memory alchemyApiKey = vm.envOr("API_KEY_ALCHEMY", string("")); // TODO - remove

        // Note - owner becomes 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496
        est = new ETHStakingIndex();

        // Fund user1
        vm.prank(stETHWhale);
        stETH.transfer(user1, ONE_THOUSAND);
        vm.prank(rETHWhale);
        rETH.transfer(user1, ONE_THOUSAND);
        vm.prank(cbETHWhale);
        cbETH.transfer(user1, ONE_THOUSAND);

        // Approve est to spend user1's tokens
        vm.startPrank(user1);
        stETH.approve(address(est), ONE_THOUSAND);
        rETH.approve(address(est), ONE_THOUSAND);
        cbETH.approve(address(est), ONE_THOUSAND);
        vm.stopPrank();
    }

    /// @dev Make sure stETH, rETH, and cbETH addresses are setup correctly
    function test_indexTokens() external {
        address[] memory tokens = est.indexTokens();
        vm.createSelectFork({ urlOrAlias: "mainnet", blockNumber: 18_823_000 });
        assertEq(ERC20(tokens[0]).symbol(), "stETH", "stETH address mismatch");
        assertEq(ERC20(tokens[1]).symbol(), "rETH", "rETH address mismatch");
        assertEq(ERC20(tokens[2]).symbol(), "cbETH", "cbETH address mismatch");
    }

    /// @dev Make sure stETH, rETH, and cbETH addresses are setup correctly
    function test_mint() external {
        // Mint 1000 tokens
        vm.prank(user1);
        est.mint(ONE_HUNDRED);

        // Check balances
        // TODO - won't work for stETH
        // assertEq(stETH.balanceOf(address(est)), ONE_THOUSAND - ONE_HUNDRED, "stETH balance mismatch");
        assertEq(rETH.balanceOf(address(user1)), ONE_THOUSAND - ONE_HUNDRED, "rETH balance mismatch");
        assertEq(cbETH.balanceOf(address(user1)), ONE_THOUSAND - ONE_HUNDRED, "cbETH balance mismatch");
        assertEq(est.balanceOf(user1), ONE_HUNDRED, "Index token balance mismatch");
    }

    // TODO test_mint_fail with vm.expectRevert
}
